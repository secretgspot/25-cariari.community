By default, Supabase Storage does NOT automatically delete old files when you upload a new one. This means you'll need to manually handle old avatar file deletion to prevent storage waste. Here's a recommended approach:

Client-side Upload Strategy:

```js
async function updateProfileAvatar(file) {
  const user = supabase.auth.user();

  // 1. Get the current avatar URL from profiles table
  const { data: profileData } = await supabase
    .from('profiles')
    .select('image_url')
    .eq('id', user.id)
    .single();

  // 2. Upload new avatar
  const { data: uploadData, error: uploadError } = await supabase.storage
    .from('uploads')
    .upload(`avatars/${user.id}/avatar.jpg`, file, {
      cacheControl: '3600',
      upsert: true,  // This will overwrite existing file
      metadata: {
        type: 'avatar',
        userId: user.id
      }
    });

  // 3. Delete old avatar file if it exists and is different
  if (profileData.image_url) {
    // Extract the file path from the full URL
    const oldAvatarPath = profileData.image_url.split(`${supabase.storageUrl}/object/public/uploads/`)[1];

    if (oldAvatarPath) {
      await supabase.storage
        .from('uploads')
        .remove([oldAvatarPath]);
    }
  }

  // 4. Update profiles table with new avatar URL
  await supabase
    .from('profiles')
    .update({
      image_url: `${supabase.storageUrl}/object/public/uploads/avatars/${user.id}/avatar.jpg`
    })
    .eq('id', user.id);
}
```

Key points:

- Uses upsert: true to overwrite existing files
- Manually deletes the old avatar file
- Stores avatars in a predictable path: avatars/{user_id}/avatar.jpg
- Updates the profiles table with the new image URL

Alternative: Periodic Cleanup If you have many users and want to ensure no orphaned files, create a background job or edge function to:

- List all files in the uploads/avatars/ directory
- Compare with current image_url in profiles table
- Delete files not referenced by any profile

cleanup-avatar-storage

```js
import { createClient } from 'jsr:@supabase/supabase-js@^2';

Deno.serve(async (req) => {
  // Ensure this is only callable by service role
  if (req.headers.get('Authorization') !== `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`) {
    return new Response('Unauthorized', { status: 403 });
  }

  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
  );

  try {
    // 1. Get all current avatar URLs from profiles
    const { data: profiles, error: profileError } = await supabase
      .from('profiles')
      .select('image_url');

    if (profileError) throw profileError;

    // 2. List all avatar files
    const { data: avatarFiles, error: listError } = await supabase.storage
      .from('uploads')
      .list('avatars', {
        limit: 1000,  // Adjust as needed
        offset: 0,
        sortBy: { column: 'name', order: 'asc' }
      });

    if (listError) throw listError;

    // 3. Find and remove orphaned avatar files
    const currentAvatarUrls = new Set(
      profiles
        .map(p => p.image_url)
        .filter(url => url !== null)
    );

    const filesToDelete = avatarFiles
      .filter(file =>
        !currentAvatarUrls.has(`${supabase.storageUrl}/object/public/uploads/avatars/${file.name}`)
      )
      .map(file => `avatars/${file.name}`);

    // 4. Delete orphaned files
    if (filesToDelete.length > 0) {
      const { error: deleteError } = await supabase.storage
        .from('uploads')
        .remove(filesToDelete);

      if (deleteError) throw deleteError;
    }

    return new Response(
      JSON.stringify({
        deletedFiles: filesToDelete.length
      }),
      {
        headers: { 'Content-Type': 'application/json' }
      }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
});
```

Recommendations:

1. Use the client-side approach for immediate, per-upload cleanup
2. Set up the Edge Function to run periodically (e.g., weekly) as a backup cleanup mechanism
3. Schedule this via Supabase Cron Jobs or your preferred scheduling metho